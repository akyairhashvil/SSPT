package tui

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/akyairhashvil/SSPT/internal/database"
	"github.com/akyairhashvil/SSPT/internal/models"
)

// GenerateReport creates a markdown summary of the day's activity.
func GenerateReport(dayID int64, workspaceID int64) {
	day, _ := database.GetDay(dayID)
	sprints, _ := database.GetSprints(dayID, workspaceID)

	// Ensure we have a data directory or just save to root
	filename := fmt.Sprintf("productivity_%s.md", day.Date)

	// Get absolute path for clarity in the print output
	absPath, _ := filepath.Abs(filename)

	f, err := os.Create(filename)
	if err != nil {
		// In a TUI, we might want to log this to a debug file or show a status message
		// For now, we just return to avoid crashing
		return
	}
	defer f.Close()

	// Header
	f.WriteString(fmt.Sprintf("# Productivity Report: %s\n\n", day.Date))
	f.WriteString("Generated by SSPT (Simple Sprint Productivity Tool)\n\n")

	totalCompleted := 0
	totalGoals := 0

	// Fetch ALL goals to build complete context
	allGoals, _ := database.GetAllGoals()
	masterTree := BuildHierarchy(allGoals)

	// Helper to check relevancy
	var isRelevant func(g models.Goal, sprintID int64) bool
	isRelevant = func(g models.Goal, sprintID int64) bool {
		if g.SprintID.Valid && g.SprintID.Int64 == sprintID {
			return true
		}
		for _, sub := range g.Subtasks {
			if isRelevant(sub, sprintID) {
				return true
			}
		}
		return false
	}

	// Iterate Sprints
	for _, s := range sprints {
		// Filter MasterTree for this sprint
		var relevantRoots []models.Goal
		for _, root := range masterTree {
			if isRelevant(root, s.ID) {
				relevantRoots = append(relevantRoots, root)
			}
		}
		
		flatGoals := Flatten(relevantRoots, 0, nil) // Expand all

		timeRange := "Pending"
		if s.StartTime.Valid {
			start := s.StartTime.Time.Format("15:04")
			end := "??"
			if s.EndTime.Valid {
				end = s.EndTime.Time.Format("15:04")
			}
			timeRange = fmt.Sprintf("%s - %s", start, end)
		}

		f.WriteString(fmt.Sprintf("## Sprint %d (%s)\n", s.SprintNumber, timeRange))

		if len(flatGoals) == 0 {
			f.WriteString("*No goals assigned.*\n")
		}

		for _, g := range flatGoals {
			totalGoals++
			check := "[ ]"
			if g.Status == "completed" {
				check = "[x]"
				totalCompleted++
			}
			indent := ""
			if g.Level > 0 {
				indent = "    " // Markdown indent
			}
			f.WriteString(fmt.Sprintf("%s- %s %s\n", indent, check, g.Description))
		}
		f.WriteString("\n")
	}

	// Summary Metrics
	completionRate := 0.0
	if totalGoals > 0 {
		completionRate = (float64(totalCompleted) / float64(totalGoals)) * 100
	}

	f.WriteString("---\n")
	f.WriteString("### Daily Metrics\n")
	f.WriteString(fmt.Sprintf("- **Total Goals:** %d\n", totalGoals))
	f.WriteString(fmt.Sprintf("- **Completed:** %d\n", totalCompleted))
	f.WriteString(fmt.Sprintf("- **Completion Rate:** %.1f%%\n", completionRate))
	f.WriteString("\n")

	// Journal
	entries, _ := database.GetJournalEntries(dayID, workspaceID)
	if len(entries) > 0 {
		f.WriteString("## Journal\n\n")
		for _, e := range entries {
			timeStr := e.CreatedAt.Format("15:04")
			f.WriteString(fmt.Sprintf("- **%s**: %s\n", timeStr, e.Content))
		}
	}

	// Print to console (stdout) so the user sees it after the TUI quits
	// Note: Since Bubbletea is running, this might get swallowed until exit,
	// but since we call tea.Quit() right after, it should appear.
	fmt.Printf("\nðŸ“„ Report generated successfully: %s\n", absPath)
}
